<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Цифровой двойник газового сепаратора ГС</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #080bc7 0%, #080bc7 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 10px 20px 20px 20px; /* чуть ближе к верху */
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 350px 1fr 400px;
            gap: 25px;
            height: auto;
            align-items: stretch; /* все окна по одной высоте */
        }

        .header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px 0;
            border-bottom: 3px solid #4681e0;
            margin-bottom: 20px;
            background: rgba(0, 173, 181, 0.1);
            border-radius: 15px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            color: #ffffff !important;
            text-shadow: 0 0 10px rgba(70, 129, 224, 0.8);
        }

        .header p {
            color: #8f8f8f;
            font-size: 16px;
        }

        .control-panel {
            background: #ffffff; /* окно белое */
            color: #000000;      /* текст окна чёрный */
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px 25px 35px 25px;
            border: 2px solid rgba(70, 129, 224, 0.8);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
            position: relative;
            overflow-y: auto;   /* вертикальный скролл для левой панели */
            overflow-x: hidden; /* без горизонтального скролла */
            height: 650px;      /* та же высота, что у окна цифрового двойника */
        }

        .control-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, #4681e0, #4681e0);
        }

        .tabs {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }

        .tab {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            color: #eeeeee;
            padding: 18px 20px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: left;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tab:hover {
            background: rgba(70, 129, 224, 0.8);
            border-color: rgba(70, 129, 224, 0.8);
            transform: translateX(8px);
        }

        .tab.active {
            background: linear-gradient(135deg, rgba(70, 129, 224, 0.8), rgba(70, 129, 224, 0.8));
            border-color: #4681e0;
            box-shadow: 0 0 20px rgba(70, 129, 224, 0.8);
        }

        .tab i {
            font-size: 20px;
            color: #4681e0;
        }

        .tab-content {
            display: none;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tab-content.active {
            display: block;
        }

        .control-group {
            background: #ffffff;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 1px solid rgb(255, 255, 255);
            position: relative;
        }

        .control-group h3 {
            color: #4681e0;
            margin-bottom: 20px;
            font-size: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-group .prediction-text {
            color: #000000;
        }

        .control-group .slider-labels {
            color: #000000;
        }

        .control-group .effect-label {
            color: #000000;
        }

        .control-group .effect-item {
            background: rgba(240, 240, 240, 0.8);
            border: 1px solid rgba(70, 129, 224, 0.3);
        }

        .current-value {
            font-size: 28px;
            font-weight: bold;
            color: #4681e0;
            text-shadow: 0 0 5px rgba(70, 129, 224, 0.8);
        }

        .slider-container {
            margin: 30px 0;
            position: relative;
        }

        .slider {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #4681e0 0%, #4681e0 50%, #4681e0 100%);
            border-radius: 5px;
            outline: none;
            border: 2px solid rgb(255, 255, 255);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #4681e0;
            cursor: pointer;
            border: 3px solid #0a1931;
            box-shadow: 0 0 15px rgba(70, 129, 224, 0.8);
            transition: all 0.3s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            background: #4681e0;
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(70, 129, 224, 0.8);
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            color: #ffffff;
            font-size: 14px;
        }

        .diameter-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .diameter-option {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            color: #eeeeee;
            padding: 18px 10px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 16px;
        }

        .diameter-option:hover {
            background: rgba(0, 173, 181, 0.2);
            transform: translateY(-3px);
        }

        .diameter-option.active {
            background: linear-gradient(135deg, #4681e0, #4681e0);
            color: #0a1931;
            border-color: #4681e0;
            box-shadow: 0 5px 15px rgba(70, 129, 224, 0.8);
            transform: translateY(-3px);
        }

        .visualization {
            background: #ffffff; /* окно белое */
            color: #000000;      /* текст окна чёрный */
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px 30px 40px 30px;
            border: 2px solid rgba(70, 129, 224, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
            position: relative;
            overflow: hidden;
            height: 650px; /* базовая высота для цифрового двойника */
        }

        .visualization::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, #4681e0, #4681e0);
        }

        .canvas-container {
            width: 100%;
            height: 650px; /* 2D модель выше */
            position: relative;
            background: linear-gradient(180deg, #ffffff 0%, #ffffff 100%); /* фон 2D модели серый */
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(70, 129, 224, 0.8);
        }

        #separator-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .process-label {
            position: absolute;
            background: rgba(70, 129, 224, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            border: 2px solid #4681e0;
            box-shadow: 0 0 10px rgba(70, 129, 224, 0.8);
            z-index: 10;
        }

        .model-name {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            text-align: center;
            width: 100%;
            border: 1px solid rgba(70, 129, 224, 0.8);
        }

        .model-name h3 {
            color: #4681e0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .model-code {
            font-size: 24px;
            font-weight: bold;
            color: #4681e0;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(70, 129, 224, 0.8);
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid #4681e0;
        }

        .predictions {
            background: #ffffff; /* окно белое */
            color: #000000;      /* текст окна чёрный */
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px 25px 40px 25px;
            border: 2px solid rgba(70, 129, 224, 0.8);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            gap: 25px;
            overflow-y: auto;   /* вертикальный скролл для данных */
            height: 650px;      /* та же высота, что у других окон */
        }

        .predictions::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, #4681e0, #4681e0);
        }

        .prediction-card {
            background: linear-gradient(135deg, rgba(0, 173, 181, 0.1), rgba(0, 255, 245, 0.05));
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #4681e0;
            border-top: 1px solid rgba(70, 129, 224, 0.8);
            transition: all 0.3s ease;
        }

        .prediction-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .prediction-card.warning {
            border-left-color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 255, 0, 0.05));
        }

        .prediction-card.danger {
            border-left-color: #ff416c;
            background: linear-gradient(135deg, rgba(255, 65, 108, 0.1), rgba(255, 0, 60, 0.05));
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 65, 108, 0.7); }
            70% { transform: scale(1.02); box-shadow: 0 0 0 10px rgba(255, 65, 108, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 65, 108, 0); }
        }

        .prediction-card h3 {
            color: #4681e0;
            margin-bottom: 15px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .prediction-value {
            font-size: 32px;
            font-weight: bold;
            color: #4681e0;
            margin: 15px 0;
            text-shadow: 0 0 5px rgba(70, 129, 224, 0.8);
        }

        .prediction-text {
            color: #ffffff;
            line-height: 1.6;
            font-size: 15px;
        }

        .efficiency-bar {
            height: 20px;
            background: rgb(255, 255, 255);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(70, 129, 224, 0.8);
        }

        .efficiency-fill {
            height: 100%;
            background: linear-gradient(90deg, #0a1931 0%, #00adb5 50%, #00fff5 100%);
            border-radius: 10px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .efficiency-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgb(255, 255, 255) 50%, 
                transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .efficiency-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            color: #fffdfd;
            font-size: 14px;
        }

        .status-indicator {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 8px currentColor;
        }

        .status-optimal { 
            background: #00ff88;
            color: #00ff88;
        }
        .status-warning { 
            background: #ffd700;
            color: #ffd700;
        }
        .status-danger { 
            background: #ff416c;
            color: #ff416c;
        }

        .warning-alert {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
            padding: 20px;
            border-radius: 15px;
            margin-top: 15px;
            animation: shake 0.5s ease, glow 1s infinite alternate;
            border: 2px solid #ff4b2b;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }

        @keyframes glow {
            from { box-shadow: 0 0 20px rgba(255, 65, 108, 0.5); }
            to { box-shadow: 0 0 30px rgba(255, 65, 108, 0.8); }
        }

        .warning-alert h4 {
            color: white;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 18px;
        }

        .footer {
            grid-column: 1 / -1;
            text-align: center;
            padding: 25px;
            border-top: 2px solid #4681e0;
            margin-top: 30px;
            color: #ffffff;
            font-size: 14px;
            background: rgba(0, 173, 181, 0.1);
            border-radius: 15px;
        }

        .flow-indicator {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .gas-bubble {
            position: absolute;
            background: rgba(70, 129, 224, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(70, 129, 224, 0.8);
        }

        .liquid-drop {
            position: absolute;
            background: rgba(70, 129, 224, 0.8);
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
        }

        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .canvas-container {
                height: 500px; /* на узких экранах тоже немного больше */
            }
        }

        /* Блок "Модель аппарата" скрыт */
        .model-name {
            display: none;
        }

        /* Вкладка и содержимое "Диаметр аппарата" скрыты */
        .tab[data-tab="diameter"],
        #diameter-content {
            display: none;
        }

        .parameter-effects {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .effect-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 173, 181, 0.2);
            text-align: center;
        }

        .effect-value {
            font-size: 20px;
            font-weight: bold;
            color: #4681e0;
            margin: 5px 0;
        }

        .effect-label {
            font-size: 12px;
            color: #ffffff;
        }

        /* Весь текст делаем чёрным поверх локальных цветов */
        body, body * {
            color: #000000 !important;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-industry"></i> Цифровой двойник газового сепаратора ГС</h1>
        </div>

        <div class="control-panel">
            <div class="tabs">
                <button class="tab active" data-tab="pressure">
                    <i class="fas fa-tachometer-alt"></i> Давление (P)
                </button>
                <button class="tab" data-tab="flow">
                    <i class="fas fa-wind"></i> Производительность (Q)
                </button>
                <button class="tab" data-tab="diameter">
                    <i class="fas fa-arrows-alt-h"></i> Диаметр аппарата (D)
                </button>
            </div>

            <div id="pressure-content" class="tab-content active">
                <div class="control-group">
                    <h3>Давление (P) <span class="current-value" id="pressure-value">2.5 МПа</span></h3>
                    <p class="prediction-text">Влияет на скорость потока, эффективность сепарации и размер пузырьков</p>
                    <div class="slider-container">
                        <input type="range" min="0.6" max="10" step="0.1" value="2.5" class="slider" id="pressure-slider">
                        <div class="slider-labels">
                            <span>0.6 МПа</span>
                            <span>10.0 МПа</span>
                        </div>
                    </div>
                    <div class="parameter-effects">
                        <div class="effect-item">
                            <div class="effect-value" id="bubble-size">Средние</div>
                            <div class="effect-label">Размер пузырьков</div>
                        </div>
                        <div class="effect-item">
                            <div class="effect-value" id="flow-speed">Средняя</div>
                            <div class="effect-label">Скорость потока</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="flow-content" class="tab-content">
                <div class="control-group">
                    <h3>Производительность (Q) <span class="current-value" id="flow-value">40,795 м³/ч</span></h3>
                    <p class="prediction-text">Определяет интенсивность потока и количество обрабатываемого газа</p>
                    <div class="slider-container">
                        <input type="range" min="10000" max="66000" step="100" value="40795" class="slider" id="flow-slider">
                        <div class="slider-labels">
                            <span>10,000 м³/ч</span>
                            <span>66,000 м³/ч</span>
                        </div>
                    </div>
                    <div class="parameter-effects">
                        <div class="effect-item">
                            <div class="effect-value" id="particle-count">Среднее</div>
                            <div class="effect-label">Количество частиц</div>
                        </div>
                        <div class="effect-item">
                            <div class="effect-value" id="turbulence">Умеренная</div>
                            <div class="effect-label">Турбулентность</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="diameter-content" class="tab-content">
                <div class="control-group">
                    <h3>Диаметр аппарата (D) <span class="current-value" id="diameter-value">1200 мм</span></h3>
                    <p class="prediction-text">Влияет на время пребывания газа и эффективность осаждения</p>
                    <div class="diameter-selector">
                        <div class="diameter-option active" data-diameter="600">600 мм</div>
                        <div class="diameter-option" data-diameter="800">800 мм</div>
                        <div class="diameter-option" data-diameter="1200">1200 мм</div>
                        <div class="diameter-option" data-diameter="1600">1600 мм</div>
                        <div class="diameter-option" data-diameter="2000">2000 мм</div>
                    </div>
                    <div class="parameter-effects">
                        <div class="effect-item">
                            <div class="effect-value" id="residence-time">Среднее</div>
                            <div class="effect-label">Время пребывания</div>
                        </div>
                        <div class="effect-item">
                            <div class="effect-value" id="separation-space">Хорошее</div>
                            <div class="effect-label">Пространство сепарации</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="visualization">
            <div class="canvas-container">
                <canvas id="separator-canvas" width="800" height="500"></canvas>
                <div class="canvas-overlay">
                    <div class="process-label" style="top: 15%; right: 10%;">Выход газа</div>
                    <div class="process-label" style="bottom: 10%; left: 50%; transform: translateX(-50%);">Дренаж жидкости</div>
                    <div class="process-label" style="top: 35%; left: 50%; transform: translate(-50%, -50%);">Сетчатый фильтр</div>
                </div>
            </div>
            
            <div class="model-name">
                <h3><i class="fas fa-tag"></i> Модель аппарата</h3>
                <div class="model-code" id="model-code">ГС-1-2.5-1200</div>
            </div>
        </div>

        <div class="predictions">
            <div class="prediction-card">
                <h3><i class="fas fa-chart-line"></i> Эффективность сепарации</h3>
                <div class="prediction-value" id="efficiency-value">97.5%</div>
                <div class="efficiency-bar">
                    <div class="efficiency-fill" id="efficiency-fill" style="width: 97.5%"></div>
                </div>
                <div class="efficiency-labels">
                    <span>70%</span>
                    <span>85%</span>
                    <span>99.9%</span>
                </div>
                <p class="prediction-text" id="efficiency-text">
                    <span class="status-indicator status-optimal"></span>
                    Режим оптимальный. Эффективность сепарации высокая.
                </p>
            </div>

            <div class="prediction-card">
                <h3><i class="fas fa-tint"></i> Качество на выходе</h3>
                <div class="prediction-value" id="quality-value">10.0 см³/1000м³</div>
                <div class="prediction-text">
                    <i class="fas fa-arrow-up" style="color: #00ff88; margin-right: 5px;"></i>
                    Содержание жидкости в очищенном газе. Норма: ≤ 20 см³/1000м³
                </div>
            </div>

            <div class="prediction-card">
                <h3><i class="fas fa-cogs"></i> Загрузка по жидкости</h3>
                <div class="prediction-value" id="loading-value">120 см³/м³</div>
                <div class="prediction-text">
                    <i class="fas fa-water" style="color: #00fff5; margin-right: 5px;"></i>
                    Содержание жидкости на входе. Норма: ≤ 200 см³/м³
                </div>
            </div>

            <div class="prediction-card">
                <h3><i class="fas fa-hourglass-half"></i> Процессы внутри</h3>
                <div class="prediction-text">
                    <div style="margin-bottom: 10px;">
                        <i class="fas fa-bubble" style="color: #00fff5; margin-right: 8px;"></i>
                        <span>Поток газа: <span id="process-flow">Умеренный</span></span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <i class="fas fa-droplet" style="color: #00adb5; margin-right: 8px;"></i>
                        <span>Осаждение капель: <span id="process-settling">Эффективное</span></span>
                    </div>
                    <div>
                        <i class="fas fa-filter" style="color: #ffffff; margin-right: 8px;"></i>
                        <span>Работа фильтра: <span id="process-filter">Оптимальная</span></span>
                    </div>
                </div>
            </div>

            <div id="warnings-container">
                <!-- Предупреждения будут добавляться динамически -->
            </div>
        </div>

        <div class="footer">
        </div>
    </div>

    <script>
        // Данные для каждого диаметра
        const diameterData = {
            600: { 
                maxPressure: 8.8, 
                maxFlow: 16530,
                volume: 0.8,
                type: "ГС1",
                height: 300
            },
            800: { 
                maxPressure: 8.8, 
                maxFlow: 29380,
                volume: 1.6,
                type: "ГС1",
                height: 400
            },
            1200: { 
                maxPressure: 8.8, 
                maxFlow: 66055,
                volume: 4.0,
                type: "ГС1",
                height: 500
            },
            1600: { 
                maxPressure: 6.3, 
                maxFlow: 114805,
                volume: 8.0,
                type: "ГС2",
                height: 600
            },
            2000: { 
                maxPressure: 4.0, 
                maxFlow: 150795,
                volume: 16.0,
                type: "ГС2",
                height: 700
            }
        };

        // Эмпирический коэффициент
        const k = 40795 / (2.5 * Math.pow(1200, 2));

        // Текущие значения
        let currentDiameter = 1200;
        let currentPressure = 2.5;
        let currentFlow = 40795;
        let isAutoRecalc = true;

        // Объекты для визуализации
        let gasBubbles = [];
        let liquidDrops = [];
        let canvas, ctx;
        let animationId;
        let lastTime = 0;

        // Инициализация вкладок
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(`${tabId}-content`).classList.add('active');
            });
        });

        // Инициализация выбора диаметра
        document.querySelectorAll('.diameter-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.diameter-option').forEach(o => o.classList.remove('active'));
                option.classList.add('active');
                
                const newDiameter = parseInt(option.getAttribute('data-diameter'));
                updateDiameter(newDiameter);
            });
        });

        // Обработчики слайдеров
        document.getElementById('pressure-slider').addEventListener('input', function() {
            if (!isAutoRecalc) return;
            updatePressure(parseFloat(this.value));
        });

        document.getElementById('flow-slider').addEventListener('input', function() {
            if (!isAutoRecalc) return;
            updateFlow(parseInt(this.value));
        });

        // Функция обновления давления
        function updatePressure(newPressure) {
            isAutoRecalc = false;
            
            currentPressure = newPressure;
            document.getElementById('pressure-value').textContent = `${newPressure.toFixed(1)} МПа`;
            document.getElementById('pressure-slider').value = newPressure;
            
            // Обновление визуальных эффектов
            updateBubbleSize();
            updateFlowSpeed();
            
            const calculatedFlow = k * currentPressure * Math.pow(currentDiameter, 2);
            const maxFlow = diameterData[currentDiameter].maxFlow;
            currentFlow = Math.min(calculatedFlow, maxFlow);
            
            updateFlowDisplay();
            updateModelCode();
            updatePredictions();
            
            isAutoRecalc = true;
        }

        // Функция обновления производительности
        function updateFlow(newFlow) {
            isAutoRecalc = false;
            
            const maxFlow = diameterData[currentDiameter].maxFlow;
            currentFlow = Math.min(newFlow, maxFlow);
            
            document.getElementById('flow-value').textContent = `${currentFlow.toLocaleString('ru-RU')} м³/ч`;
            document.getElementById('flow-slider').value = currentFlow;
            
            // Обновление визуальных эффектов
            updateParticleCount();
            updateTurbulence();
            
            const calculatedPressure = currentFlow / (k * Math.pow(currentDiameter, 2));
            const maxPressure = diameterData[currentDiameter].maxPressure;
            currentPressure = Math.min(calculatedPressure, maxPressure);
            
            document.getElementById('pressure-value').textContent = `${currentPressure.toFixed(1)} МПа`;
            document.getElementById('pressure-slider').value = currentPressure;
            
            updateModelCode();
            updatePredictions();
            
            isAutoRecalc = true;
        }

        // Функция обновления диаметра
        function updateDiameter(newDiameter) {
            isAutoRecalc = false;
            
            currentDiameter = newDiameter;
            document.getElementById('diameter-value').textContent = `${newDiameter} мм`;
            
            // Обновление визуальных эффектов
            updateResidenceTime();
            updateSeparationSpace();
            
            const maxPressure = diameterData[newDiameter].maxPressure;
            const maxFlow = diameterData[newDiameter].maxFlow;
            
            document.getElementById('pressure-slider').max = maxPressure;
            document.getElementById('flow-slider').max = maxFlow;
            
            if (currentPressure > maxPressure) {
                currentPressure = maxPressure;
            }
            
            if (currentFlow > maxFlow) {
                currentFlow = maxFlow;
            }
            
            document.getElementById('pressure-value').textContent = `${currentPressure.toFixed(1)} МПа`;
            document.getElementById('pressure-slider').value = currentPressure;
            
            document.getElementById('flow-value').textContent = `${currentFlow.toLocaleString('ru-RU')} м³/ч`;
            document.getElementById('flow-slider').value = currentFlow;
            
            updateModelCode();
            updatePredictions();
            
            isAutoRecalc = true;
        }

        // Визуальные эффекты параметров
        function updateBubbleSize() {
            const size = currentPressure < 2 ? "Мелкие" : currentPressure < 5 ? "Средние" : "Крупные";
            document.getElementById('bubble-size').textContent = size;
        }

        function updateFlowSpeed() {
            const speed = currentPressure < 2 ? "Низкая" : currentPressure < 5 ? "Средняя" : "Высокая";
            document.getElementById('flow-speed').textContent = speed;
        }

        function updateParticleCount() {
            const flowRatio = currentFlow / diameterData[currentDiameter].maxFlow;
            const count = flowRatio < 0.3 ? "Мало" : flowRatio < 0.7 ? "Среднее" : "Много";
            document.getElementById('particle-count').textContent = count;
        }

        function updateTurbulence() {
            const flowRatio = currentFlow / diameterData[currentDiameter].maxFlow;
            const turbulence = flowRatio < 0.3 ? "Низкая" : flowRatio < 0.7 ? "Умеренная" : "Высокая";
            document.getElementById('turbulence').textContent = turbulence;
        }

        function updateResidenceTime() {
            const times = {
                600: "Короткое",
                800: "Короткое",
                1200: "Среднее",
                1600: "Длительное",
                2000: "Очень длительное"
            };
            document.getElementById('residence-time').textContent = times[currentDiameter];
        }

        function updateSeparationSpace() {
            const spaces = {
                600: "Ограниченное",
                800: "Умеренное",
                1200: "Хорошее",
                1600: "Отличное",
                2000: "Оптимальное"
            };
            document.getElementById('separation-space').textContent = spaces[currentDiameter];
        }

        // Инициализация Canvas
        function initCanvas() {
            canvas = document.getElementById('separator-canvas');
            ctx = canvas.getContext('2d');
            
            // Создание начальных частиц
            createParticles();
            
            // Запуск анимации
            animate();
        }

        // Создание частиц
        function createParticles() {
            gasBubbles = [];
            liquidDrops = [];
            
            const width = 300;
            const height = 400;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;
            
            const particleCount = Math.min(100, Math.floor(currentFlow / 1000));
            
            for (let i = 0; i < particleCount; i++) {
                // Создаём пузырьки только внутри сепаратора (с отступом от краёв)
                gasBubbles.push({
                    x: x + 20 + Math.random() * (width - 40),
                    y: y + 20 + Math.random() * (height - 40),
                    size: Math.random() * 4 + 2,
                    speed: (currentPressure / 5) * (Math.random() * 2 + 1),
                    opacity: Math.random() * 0.5 + 0.5,
                    type: 'bubble'
                });
                
                if (i % 3 === 0) {
                    liquidDrops.push({
                        x: x + 20 + Math.random() * (width - 40),
                        y: y + 20 + Math.random() * (height - 40),
                        size: Math.random() * 3 + 1,
                        speed: (currentPressure / 10) * (Math.random() + 0.5),
                        falling: Math.random() > 0.5,
                        type: 'drop'
                    });
                }
            }
        }

        // Анимация
        function animate(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Очистка canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Рисование сепаратора
            drawSeparator();
            
            // Обновление и отрисовка частиц
            updateParticles(deltaTime);
            drawParticles();
            
            // Рисование уровня жидкости
            drawLiquidLevel();
            
            // Рисование фильтра
            drawFilter();
            
            // Рисование потоков
            drawFlowArrows();
            
            animationId = requestAnimationFrame(animate);
        }

        // Рисование сепаратора
        function drawSeparator() {
            const width = 300;
            const height = 400;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;
            
            // Корпус (серый)
            ctx.fillStyle = 'rgba(120, 120, 120, 0.95)';
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(x, y, width, height, 10);
            ctx.fill();
            ctx.stroke();
            
            // Верхняя крышка (светло‑серая)
            ctx.fillStyle = 'rgba(190, 190, 190, 0.9)';
            ctx.beginPath();
            ctx.ellipse(x + width/2, y, width/2, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Нижняя крышка (светло‑серая)
            ctx.beginPath();
            ctx.ellipse(x + width/2, y + height, width/2, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Выходной патрубок (серый)
            ctx.beginPath();
            ctx.roundRect(x + width, y + 100, 40, 60, 5);
            ctx.fill();
            ctx.stroke();
            
            // Дренаж (тёмно‑серый)
            ctx.fillStyle = 'rgba(80, 80, 80, 0.95)';
            ctx.beginPath();
            ctx.roundRect(x + width/2 - 25, y + height, 50, 30, 5);
            ctx.fill();
            ctx.stroke();
        }

        // Рисование фильтра
        function drawFilter() {
            const width = 300;
            const height = 400;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;

            // Задаём смещённую вверх зону фильтра
            const filterTop = y + 20;
            const filterBottom = y + height - 120;
            
            ctx.strokeStyle = 'rgba(0, 255, 245, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // Вертикальные линии фильтра
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo(x + 30 + i * 24, filterTop);
                ctx.lineTo(x + 30 + i * 24, filterBottom);
                ctx.stroke();
            }
            
            // Горизонтальные линии фильтра
            const rows = 12;
            const rowStep = (filterBottom - filterTop) / rows;
            for (let i = 0; i <= rows; i++) {
                const yPos = filterTop + i * rowStep;
                ctx.beginPath();
                ctx.moveTo(x + 30, yPos);
                ctx.lineTo(x + width - 30, yPos);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // Подсветка фильтра
            const gradient = ctx.createLinearGradient(x, filterTop, x, filterBottom);
            gradient.addColorStop(0, 'rgba(0, 255, 245, 0.1)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 245, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 255, 245, 0.1)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x + 30, filterTop, width - 60, filterBottom - filterTop);
        }

        // Рисование уровня жидкости
        function drawLiquidLevel() {
            const maxFlow = diameterData[currentDiameter].maxFlow;
            const loading = 200 * (currentFlow / maxFlow);
            const liquidHeight = (loading / 200) * 100;
            
            const width = 300;
            const height = 400;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;
            
            const liquidY = y + height - liquidHeight;
            
            // Жидкость (чёрная)
            const liquidGradient = ctx.createLinearGradient(0, liquidY, 0, y + height);
            liquidGradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
            liquidGradient.addColorStop(1, 'rgba(0, 0, 0, 0.7)');
            
            ctx.fillStyle = liquidGradient;
            ctx.beginPath();
            ctx.roundRect(x + 5, liquidY, width - 10, liquidHeight, 5);
            ctx.fill();
            
            // Анимация поверхности жидкости (светло‑серая линия)
            ctx.strokeStyle = 'rgba(220, 220, 220, 0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 5, liquidY);
            
            for (let i = 0; i < width - 10; i += 5) {
                const wave = Math.sin(Date.now() / 1000 + i * 0.1) * 2;
                ctx.lineTo(x + 5 + i, liquidY + wave);
            }
            
            ctx.stroke();
        }

        // Обновление частиц
        function updateParticles(deltaTime) {
            const width = 300;
            const height = 400;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;
            
            // Обновление пузырьков газа (движение вверх и вправо)
            gasBubbles.forEach(bubble => {
                const dt = (deltaTime / 16);
                const vx = bubble.speed * 0.6 * dt;  // вправо
                const vy = bubble.speed * 0.8 * dt;  // вверх

                bubble.x += vx;
                bubble.y -= vy + Math.sin(Date.now() / 1000 + bubble.x * 0.01) * 0.3;
                
                // Ограничиваем пузырьки внутри сепаратора (с отступом от краёв)
                const padding = 15;
                const minX = x + padding;
                const maxX = x + width - padding;
                const minY = y + padding;
                const maxY = y + height - padding;
                
                // Отталкиваем пузырьки обратно внутрь, если они вышли за границы
                if (bubble.x < minX) {
                    bubble.x = minX;
                } else if (bubble.x > maxX) {
                    bubble.x = maxX;
                }
                
                if (bubble.y < minY) {
                    bubble.y = minY;
                } else if (bubble.y > maxY) {
                    bubble.y = maxY;
                }
                
                // Если пузырёк достиг верхней границы — перезапускаем снизу
                if (bubble.y <= minY + 5) {
                    bubble.x = minX + Math.random() * (maxX - minX);
                    bubble.y = maxY - 20 - Math.random() * 30;
                }
            });
            
            // Обновление капель жидкости
            liquidDrops.forEach(drop => {
                if (drop.falling) {
                    drop.y += drop.speed * (deltaTime / 16) * 2;
                } else {
                    drop.x += drop.speed * (deltaTime / 16) * 0.5;
                    drop.y += Math.sin(Date.now() / 500 + drop.x * 0.02) * 1;
                }
                
                // Сброс капель вниз
                if (drop.y > y + height - 50) {
                    drop.y = y + 50;
                    drop.x = Math.random() * (width - 20) + x + 10;
                    drop.falling = Math.random() > 0.7;
                }
                
                // Переход капель в режим падения при попадании в фильтр
                if (drop.x > x + 30 && drop.x < x + width - 30 && 
                    drop.y > y + 50 && drop.y < y + height - 50) {
                    if (Math.random() > 0.95) drop.falling = true;
                }
            });
        }

        // Рисование частиц
        function drawParticles() {
            const width = 300;
            const height = 400;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;
            const padding = 10;
            
            // Рисование пузырьков (светлые) - только внутри сепаратора
            gasBubbles.forEach(bubble => {
                // Проверяем, что пузырёк внутри сепаратора
                if (bubble.x >= x + padding && bubble.x <= x + width - padding &&
                    bubble.y >= y + padding && bubble.y <= y + height - padding) {
                    // Светлый голубовато-белый цвет
                    ctx.fillStyle = `rgba(200, 240, 255, ${bubble.opacity})`;
                    ctx.beginPath();
                    ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Блики на пузырьках (белый)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(bubble.x - bubble.size/3, bubble.y - bubble.size/3, bubble.size/3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Рисование капель жидкости (чёрные)
            liquidDrops.forEach(drop => {
                ctx.fillStyle = `rgba(0, 0, 0, ${drop.falling ? 0.95 : 0.8})`;
                ctx.save();
                ctx.translate(drop.x, drop.y);
                ctx.rotate(-Math.PI/4);
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(
                    -drop.size, -drop.size*2,
                    drop.size, -drop.size*2,
                    0, 0
                );
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            });
        }

        // Рисование стрелок потоков
        function drawFlowArrows() {
            const width = 300;
            const height = 400;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;
            
            // Выходной поток
            drawArrow(x + width - 10, y + 130, x + width + 30, y + 130, '#00ff88');
            
            // Поток вниз (осаждение)
            for (let i = 0; i < 3; i++) {
                const arrowX = x + 50 + i * 80;
                drawArrow(arrowX, y + 100, arrowX, y + height - 50, '#00adb5');
            }
        }

        // Вспомогательная функция для рисования стрелки
        function drawArrow(fromX, fromY, toX, toY, color) {
            const headlen = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Рисование наконечника стрелки
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI/6), toY - headlen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI/6), toY - headlen * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
        }

        // Обновление отображения производительности
        function updateFlowDisplay() {
            document.getElementById('flow-value').textContent = `${currentFlow.toLocaleString('ru-RU')} м³/ч`;
            document.getElementById('flow-slider').value = currentFlow;
        }

        // Обновление кода модели
        function updateModelCode() {
            const type = diameterData[currentDiameter].type;
            const pressureCode = currentPressure.toFixed(1).replace('.', '-');
            const modelCode = `${type}-${pressureCode}-${currentDiameter}`;
            document.getElementById('model-code').textContent = modelCode;
        }

        // Обновление прогнозов и предупреждений
        function updatePredictions() {
            const maxPressure = diameterData[currentDiameter].maxPressure;
            const maxFlow = diameterData[currentDiameter].maxFlow;
            
            // Расчет эффективности
            let efficiency = 95 + 4 * (currentPressure / maxPressure) - 3 * (currentFlow / maxFlow);
            efficiency = Math.max(70, Math.min(99.9, efficiency));
            
            // Расчет содержания жидкости
            const outletQuality = 20 * (100 - efficiency) / 5;
            const inletLoading = 200 * (currentFlow / maxFlow);
            
            // Обновление значений
            document.getElementById('efficiency-value').textContent = `${efficiency.toFixed(1)}%`;
            document.getElementById('efficiency-fill').style.width = `${efficiency}%`;
            
            document.getElementById('quality-value').textContent = `${outletQuality.toFixed(1)} см³/1000м³`;
            document.getElementById('loading-value').textContent = `${inletLoading.toFixed(1)} см³/м³`;
            
            // Обновление текста рекомендаций
            const efficiencyText = document.getElementById('efficiency-text');
            const statusIndicator = efficiencyText.querySelector('.status-indicator');
            
            if (efficiency > 98) {
                efficiencyText.innerHTML = '<span class="status-indicator status-optimal"></span> Режим оптимальный. Эффективность сепарации высокая.';
                document.getElementById('process-flow').textContent = "Стабильный";
                document.getElementById('process-settling').textContent = "Эффективное";
                document.getElementById('process-filter').textContent = "Оптимальная";
            } else if (efficiency > 95) {
                efficiencyText.innerHTML = '<span class="status-indicator status-warning"></span> Режим допустимый. Рекомендуется проверить содержание жидкости на входе.';
                document.getElementById('process-flow').textContent = "Умеренный";
                document.getElementById('process-settling').textContent = "Нормальное";
                document.getElementById('process-filter').textContent = "Нормальная";
            } else {
                efficiencyText.innerHTML = '<span class="status-indicator status-danger"></span> Эффективность ниже нормы. Требуется корректировка параметров.';
                document.getElementById('process-flow').textContent = "Турбулентный";
                document.getElementById('process-settling').textContent = "Недостаточное";
                document.getElementById('process-filter').textContent = "Перегружена";
            }
            
            // Очистка и добавление предупреждений
            const warningsContainer = document.getElementById('warnings-container');
            warningsContainer.innerHTML = '';
            
            // Проверка аварийных ситуаций
            if (currentPressure < 0.6) {
                addWarning(
                    'danger',
                    '<i class="fas fa-exclamation-triangle"></i> АВАРИЙНОЕ ПРЕДУПРЕЖДЕНИЕ',
                    'Давление ниже минимально допустимого (0.6 МПа). Риск нарушения сепарации и попадания жидкости в газопровод. Немедленно увеличьте давление.'
                );
            }
            
            if (currentPressure > maxPressure) {
                addWarning(
                    'danger',
                    '<i class="fas fa-exclamation-triangle"></i> АВАРИЙНОЕ ПРЕДУПРЕЖДЕНИЕ',
                    `Давление превышает конструктивный предел для данного типоразмера (${maxPressure} МПа). Риск разгерметизации. Немедленно снизьте давление или выберите сепаратор большего диаметра.`
                );
            }
            
            if (currentFlow > maxFlow) {
                addWarning(
                    'danger',
                    '<i class="fas fa-exclamation-triangle"></i> АВАРИЙНОЕ ПРЕДУПРЕЖДЕНИЕ',
                    `Производительность превышает паспортную (${maxFlow.toLocaleString('ru-RU')} м³/ч). Риск уноса капельной жидкости и разрушения сетчатых элементов. Немедленно снизите расход или выберите сепаратор большего диаметра.`
                );
            }
            
            if (outletQuality > 20) {
                addWarning(
                    'warning',
                    '<i class="fas fa-exclamation-circle"></i> ПРЕДУПРЕЖДЕНИЕ О КАЧЕСТВЕ',
                    'Превышено допустимое содержание жидкости на выходе (>20 см³/1000м³). Качество газа не соответствует нормативным требованиям.'
                );
            }
            
            if (inletLoading > 200) {
                addWarning(
                    'warning',
                    '<i class="fas fa-exclamation-circle"></i> ПРЕДУПРЕЖДЕНИЕ О ЗАГРУЗКЕ',
                    'Превышена допустимая загрузка по жидкости на входе (>200 см³/м³). Требуется установка предварительного отстойника.'
                );
            }
            
            // Обновление частиц
            createParticles();
        }

        // Функция добавления предупреждения
        function addWarning(type, title, message) {
            const warningsContainer = document.getElementById('warnings-container');
            const warningClass = type === 'danger' ? 'danger' : 'warning';
            
            const warningHTML = `
                <div class="prediction-card ${warningClass}">
                    <h3>${title}</h3>
                    <p class="prediction-text">${message}</p>
                </div>
            `;
            
            warningsContainer.innerHTML += warningHTML;
        }

        // Инициализация
        function initialize() {
            initCanvas();
            updateModelCode();
            updatePredictions();
            updateBubbleSize();
            updateFlowSpeed();
            updateParticleCount();
            updateTurbulence();
            updateResidenceTime();
            updateSeparationSpace();
        }

        // Запуск при загрузке страницы
        document.addEventListener('DOMContentLoaded', initialize);

        // Остановка анимации при закрытии страницы
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>
